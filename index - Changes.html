<html> 
<head>
  <style>
   *{padding: 0; margin:0;}
   canvas{ background: #eee; display: block; margin: 0 auto;}
   </style>
</head>
<body>
<canvas id= "myCanvas" width="256" height="240"></canvas>
<script src="mapsFileEdited.js"></script>
<script type="text/javascript">
let canvas = document.getElementById("myCanvas");
let ctx = canvas.getContext("2d");
document.addEventListener("keydown",keyDownHandler, false);
document.addEventListener("keyup",keyUpHandler,false);
document.body.style.zoom = "288%";
///potential ugly fix for firefox users....
//let nativeResWidth = 256;
//let nativeResHeight = 240;
//let scaleWidth = 3;
//let scaleHeight = 3;
//ctx.canvas.width  = scaleWidth * nativeResWidth;
//ctx.canvas.height = scaleHeight * nativeResHeight;
//ctx.scale(scaleWidth,scaleHeight);


let rightPressed = false;
let leftPressed = false;
let upPressed = false;
let downPressed = false;
let hasGameStarted = false;
let worldTiles = new Image();
worldTiles.src = "tiles-overworld.png";
let link1 = new Image();
link1.src = "link.png";
let enemies = new Image();
enemies.src = "enemies.png";
let chars1 = new Image();
chars1.src = "chars.png";
let chars2 = new Image();
chars2.src = "chars2.png";
let hud = new Image();
hud.src = "pausescreen.png";
let backgroundMusic = new Audio();
backgroundMusic.src = "./sounds/overworld_edit.mp3";
backgroundMusic.loop = true;
let fps = 60;
let animationCounter = 0;
let currentAnimation = 0;
let animationSpeed = 10;
let lastButtonPressed = "up";
let linkY = 135;
let linkX = 116;
let linkHearts = 14;
let linkNeedsToBounce = false;
let currentLinkHearts = 14;
let blocks = [];
let gameObjects = [];
let gameMap = [];
//let maps = [];
let isAttacking = false;
let canAttackAgain = true;
let pathFound = [];
let hasRun = false;

let rupeeAmount = 0;
let linkBounceY = -1;
let linkBounceX = -1;
let linkIsInvincible = false;
let invincibleTime = 0;
let lastPickUpItem = 0;
let playPickUpItemAnimation = false;
let swordEquipped = 0;
let hasSword = true;
/// 0 -no sword, 1 - brown, .....
let inventoryItems = [null, null, null, null, null, null, null, null, null, null, null, null, null];
let bombNum = 2;
let keyNum = 5;


gameObjects = maps[119].gameobjects;
gameMap = maps[119].map;
let currentMap = 119;
addMapGameObjects(gameMap, gameObjects);

function playSound(source)
{
	let sound = new Audio();
	sound.src = source;
	sound.play();
}




function keyDownHandler(e){
    if(e.keyCode == 37)
    {
	   leftPressed = true;
	   lastButtonPressed = "left";
	}
	else if(e.keyCode == 39)
	{
	   rightPressed = true;
	   lastButtonPressed = "right";
	}
	else if(e.keyCode == 38)
	{
	   upPressed = true;
	   lastButtonPressed = "up";
	}
	else if(e.keyCode == 40)
	{
	   downPressed = true;
	   lastButtonPressed = "down";
	}
	
	if(e.keyCode == 32 && canAttackAgain){
            isAttacking = true;
			currentAnimation = 0;
			canAttackAgain = false;
			playSound("./sounds/LOZ_sword_slash.wav")
        }
	if(e.keyCode == 13 && !hasGameStarted)
	{
		hasGameStarted = true;
		backgroundMusic.play();
	}
}

function keyUpHandler(e){
    if(e.keyCode == 37)
	{
	   leftPressed = false;
	}
	else if(e.keyCode == 39)
	{
	   rightPressed = false;
	}
	else if(e.keyCode == 38)
	{
	   upPressed = false;
	}
	else if(e.keyCode == 40)
	{
	   downPressed = false;
	}
	
	if(e.keyCode == 32){
            //isAttacking = false;
        }
}

function drawMap(level)
{
	for(let i = 0; i < level.length; i++)
	{
		for(let j = 0; j < level[i].length; j++)
		{
			ctx.drawImage(worldTiles, ((level[i][j]%18) * 17) + 1,
			(Math.floor(level[i][j]/18) * 17) + 1, 
			16, 16, j *16, i *16, 16, 16);
		}
	}
}

function drawLink()
{

	let speed = 2;
	animationCounter++;
	if(linkNeedsToBounce)
	{
		if(linkX != linkBounceX)
		{
			if(linkBounceX > linkX)
			{
				linkX += 2;
			}
			else if(linkBounceX < linkX)
			{
				linkX -= 2;
			}
		}
		else if(linkY != linkBounceY)
		{
			if(linkBounceY > linkY)
			{
				linkY += 2;
			}
			else if(linkBounceY < linkY)
			{
				linkY -= 2;
			}
		}
		else
		{
			linkNeedsToBounce = false;
			if(currentLinkHearts <= 0)
			{
				
			}
		}
		
		if(lastButtonPressed == "down")
		{
			ctx.drawImage(link1, 0, 60, 
			16, 16, linkX, linkY, 16, 16);
		}
		if(lastButtonPressed == "up")
		{
			ctx.drawImage(link1, 62, 60, 
			16, 16, linkX, linkY, 16, 16);
		}
		if(lastButtonPressed == "left")
		{
			ctx.drawImage(link1, 30, 60, 
			16, 16, linkX, linkY, 16, 16);
		}
		if(lastButtonPressed == "right")
		{
			ctx.drawImage(link1, 91, 60, 
			16, 16, linkX, linkY, 16, 16);
		}
		
	}
	else if(playPickUpItemAnimation)
	{
		animationCounter++;
		if(animationCounter < 300)
		{
			ctx.drawImage(link1, 1, 150, 
			16, 16, linkX, linkY, 16, 16);	
		}
		else
		{
			playPickUpItemAnimation = false;
		}

		switch(lastPickUpItem)
		{
			case 0:

				break;
			case 1:

				break;
			case 2:

				break;
			case 3:

				break;
			case 4:

				break;
			case 5:

				break;	
			case 6:

				break;
			case 7:

				break;
			case 8:

				break;
			case 9:

				break;
			case 10:

				break;
			case 11:

				break;
			case 12:

				break;
			case 13:

				break;
			case 14:
				ctx.drawImage(hud, 555, 137, 8, 16, 
						linkX - 2, linkY - 14, 8, 16);
				break;
		}
	}
	else
	{
	if(isAttacking && hasSword)
	{
		if(currentAnimation == 0)
			{
				if(lastButtonPressed == "down")
				{
					ctx.drawImage(link1, 0, 60, 
					16, 16, linkX, linkY, 16, 16);
				}
				if(lastButtonPressed == "up")
				{
					ctx.drawImage(link1, 62, 60, 
					16, 16, linkX, linkY, 16, 16);
				}
				if(lastButtonPressed == "left")
				{
					ctx.drawImage(link1, 30, 60, 
					16, 16, linkX, linkY, 16, 16);
				}
				if(lastButtonPressed == "right")
				{
					ctx.drawImage(link1, 91, 60, 
					16, 16, linkX, linkY, 16, 16);
				}
			}
			else if(currentAnimation == 1)
			{
				if(lastButtonPressed == "down")
				{
					ctx.drawImage(link1, 0, 84, 
					16, 27, linkX, linkY, 16, 27);
					gameObjectCollision(linkX + 7, linkY + 16, gameObjects, 
							false, true, false, 
							false, false, "down");
				}
				if(lastButtonPressed == "up")
				{
					ctx.drawImage(link1, 62, 84, 
					16, 26, linkX, linkY-14, 16, 26);
					gameObjectCollision(linkX + 5, linkY-14, gameObjects, 
							false, true, false, 
							false, false, "up");
				}
				if(lastButtonPressed == "left")
				{
					ctx.drawImage(link1, 22, 84, 
					26, 27, linkX - 10, linkY - 8, 27, 27);
					gameObjectCollision(linkX - 10, linkY -1,  gameObjects, 
							false, true, false, 
							false, false, "left");
				}
				if(lastButtonPressed == "right")
				{
					ctx.drawImage(link1, 84, 84, 
					30, 26, linkX, linkY - 8, 26, 26);
					gameObjectCollision(linkX+ 16, linkY -1, gameObjects, 
							false, true, false, 
							false, false, "right");
				};
			}
			if(animationCounter >= 6)
			{
				currentAnimation++;
				animationCounter = 0;
				if(currentAnimation > 1)
				{
					currentAnimation = 0;
					isAttacking = false;
					canAttackAgain = true;
					
				}
			}
	}
	else if(leftPressed && !collision2(linkX - speed, linkY, gameMap))
	{
			linkX -= speed;
			if(currentAnimation == 0)
			{
				ctx.drawImage(link1, 30, 0, 16, 16, linkX, linkY, 16, 16);
			}
			else if(currentAnimation == 1)
			{
				ctx.drawImage(link1, 30, 30, 16, 16,linkX, linkY, 16, 16);
			}
			if(animationCounter >= 6)
			{
				currentAnimation++;
				animationCounter = 0;
				if(currentAnimation > 1)
				{
					currentAnimation = 0;
				}
			}
	}
	else if(rightPressed && !collision2(linkX + speed, linkY, gameMap))
	{
		linkX += speed;
		if(currentAnimation == 0)
			{
				ctx.drawImage(link1, 91, 0, 16, 16, linkX, linkY, 16, 16);
			}
			else if(currentAnimation == 1)
			{
				ctx.drawImage(link1, 91, 30, 16, 16,linkX, linkY, 16, 16);
			}
			if(animationCounter >= 6)
			{
				currentAnimation++;
				animationCounter = 0;
				if(currentAnimation > 1)
				{
					currentAnimation = 0;
				}
			}
	}
	else if(upPressed && !collision2(linkX, linkY - speed, gameMap))
	{
		linkY -= speed;
		if(currentAnimation == 0)
			{
				ctx.drawImage(link1, 62, 0, 16, 16, linkX, linkY, 16, 16);
			}
			else if(currentAnimation == 1)
			{
				ctx.drawImage(link1, 62, 30, 16, 16,linkX, linkY, 16, 16);
			}
			if(animationCounter >= 6)
			{
				currentAnimation++;
				animationCounter = 0;
				if(currentAnimation > 1)
				{
					currentAnimation = 0;
				}
			}
	}
	else if(downPressed && !collision2(linkX, linkY + speed, gameMap))
	{
		linkY += speed;
		if(currentAnimation == 0)
			{
				ctx.drawImage(link1, 0, 0, 16, 16, linkX, linkY, 16, 16);
			}
			else if(currentAnimation == 1)
			{
				ctx.drawImage(link1, 0, 30, 16, 16,linkX, linkY, 16, 16);
			}
			if(animationCounter >= 6)
			{
				currentAnimation++;
				animationCounter = 0;
				if(currentAnimation > 1)
				{
					currentAnimation = 0;
				}
			}
	}
	
	else
	{
		if(lastButtonPressed == "down")
		{
			ctx.drawImage(link1, 0, 0, 
			16, 16, linkX, linkY, 16, 16);
		}
		if(lastButtonPressed == "up")
		{
			ctx.drawImage(link1, 62, 0, 
			16, 16, linkX, linkY, 16, 16);
		}
		if(lastButtonPressed == "left")
		{
			ctx.drawImage(link1, 30, 0, 
			16, 16, linkX, linkY, 16, 16);
		}
		if(lastButtonPressed == "right")
		{
			ctx.drawImage(link1, 91, 0, 
			16, 16, linkX, linkY, 16, 16);
		}
	}
	}
}

function Point(x, y)
{
	this.row = x;
	this.col = y;
}

function collision2(x, y, map)
{
	
	blocks = [];
	
	for(let i = 0; i < map.length; i++)
	{
		for(let j = 0; j < map[i].length; j++)
			{
				if(map[i][j] != 2 && map[i][j] != 28 &&
				map[i][j] != 18
				&& map[i][j] != 6
				&& map[i][j] != 12
				&& map[i][j] != 14
				&& map[i][j] != 24
				&& map[i][j] != 30
				&& map[i][j] != 34
				&& map[i][j] != 58
				&& map[i][j] != 64
				&& map[i][j] != 70
				&& map[i][j] != 75
				&& map[i][j] != 76
				&& map[i][j] != 77
				&& map[i][j] != 93
				&& map[i][j] != 94
				&& map[i][j] != 95
				&& map[i][j] != 111
				&& map[i][j] != 112
				&& map[i][j] != 113
				&& map[i][j] != 81
				&& map[i][j] != 82
				&& map[i][j] != 83
				&& map[i][j] != 99
				&& map[i][j] != 100
				&& map[i][j] != 101
				&& map[i][j] != 117
				&& map[i][j] != 118
				&& map[i][j] != 119
				&& map[i][j] != 87
				&& map[i][j] != 88
				&& map[i][j] != 89
				&& map[i][j] != 105
				&& map[i][j] != 106
				&& map[i][j] != 107
				&& map[i][j] != 123
				&& map[i][j] != 124
				&& map[i][j] != 125
				&& map[i][j] != 126
				&& map[i][j] != 127
				&& map[i][j] != 128
				&& map[i][j] != 129
				&& map[i][j] != 131
				&& map[i][j] != 132
				&& map[i][j] != 133
				&& map[i][j] != 134
				&& map[i][j] != 135
				&& map[i][j] != 137
				&& map[i][j] != 138
				&& map[i][j] != 139
				&& map[i][j] != 140
				&& map[i][j] != 141
				&& map[i][j] != 143
				)
				{
					blocks.push(new Point(i, j));
				}
			}
	}

	for(let i = 0; i < blocks.length; i++)
		{
			if (x +4<= blocks[i].col*16 + 16 &&
			   x + 12 >= blocks[i].col*16 &&
			   y + 10 <= blocks[i].row*16 + 16 &&
			   y + 16 >= blocks[i].row*16 ) {
					return true;
				}
		}
	return false;	
}

function drawGameObjects()
{
	for(let i = 0; i < gameObjects.length; i++)
	{
		if(gameObjects[i].isPickUpItem)
		{
			switch(gameObjects[i].pickUpItemNum)
			{
				case 0:
					gO = new GameObject();
					gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
					inventoryItems[gameObjects[i].pickUpItemNum] = gO;
					lastPickUpItem = gameObjects[i].pickUpItemNum;
					break;
				case 1:
					gO = new GameObject();
					gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
					inventoryItems[gameObjects[i].pickUpItemNum] = gO;
					lastPickUpItem = gameObjects[i].pickUpItemNum;
					break;
				case 2:
					gO = new GameObject();
					gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
					inventoryItems[gameObjects[i].pickUpItemNum] = gO;
					lastPickUpItem = gameObjects[i].pickUpItemNum;
					break;
				case 3:
					gO = new GameObject();
					gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
					inventoryItems[gameObjects[i].pickUpItemNum] = gO;
					lastPickUpItem = gameObjects[i].pickUpItemNum;
					break;
				case 4:
					gO = new GameObject();
					gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
					inventoryItems[gameObjects[i].pickUpItemNum] = gO;
					lastPickUpItem = gameObjects[i].pickUpItemNum;
					break;
				case 5:
					gO = new GameObject();
					gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
					inventoryItems[gameObjects[i].pickUpItemNum] = gO;
					lastPickUpItem = gameObjects[i].pickUpItemNum;
					break;	
				case 6:
					gO = new GameObject();
					gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
					inventoryItems[gameObjects[i].pickUpItemNum] = gO;
					lastPickUpItem = gameObjects[i].pickUpItemNum;
					break;
				case 7:
					gO = new GameObject();
					gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
					inventoryItems[gameObjects[i].pickUpItemNum] = gO;
					lastPickUpItem = gameObjects[i].pickUpItemNum;
					break;
				case 8:
					gO = new GameObject();
					gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
					inventoryItems[gameObjects[i].pickUpItemNum] = gO;
					lastPickUpItem = gameObjects[i].pickUpItemNum;
					break;
				case 9:
					gO = new GameObject();
					gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
					inventoryItems[gameObjects[i].pickUpItemNum] = gO;
					lastPickUpItem = gameObjects[i].pickUpItemNum;
					break;
				case 10:
					gO = new GameObject();
					gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
					inventoryItems[gameObjects[i].pickUpItemNum] = gO;
					lastPickUpItem = gameObjects[i].pickUpItemNum;
					break;
				case 11:
					gO = new GameObject();
					gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
					inventoryItems[gameObjects[i].pickUpItemNum] = gO;
					lastPickUpItem = gameObjects[i].pickUpItemNum;
					break;
				case 12:
					gO = new GameObject();
					gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
					inventoryItems[gameObjects[i].pickUpItemNum] = gO;
					lastPickUpItem = gameObjects[i].pickUpItemNum;
					break;
				case 13:
					gO = new GameObject();
					gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
					inventoryItems[gameObjects[i].pickUpItemNum] = gO;
					lastPickUpItem = gameObjects[i].pickUpItemNum;
					break;
				case 14:
					ctx.drawImage(hud, 555, 137, 8, 16, 
						gameObjects[i].x, gameObjects[i].y, 8, 16);
					break;
			}
		}
		if(gameObjects[i].isText)
		{
			gameObjects[i].counter+=1;
			if(gameObjects[i].counter%5==0)
			{
				if(gameObjects[i].line1Full.length != gameObjects[i].line1Current.length)
				{
					gameObjects[i].line1Current = gameObjects[i].line1Full.substring(0, 
					gameObjects[i].line1Current.length + 1);
					playSound("./sounds/LOZ_text_slow.wav");
				}
				else if(gameObjects[i].line2Full.length != gameObjects[i].line2Current.length)
				{
					gameObjects[i].line2Current = gameObjects[i].line2Full.substring(0, 
					gameObjects[i].line2Current.length + 1);
					playSound("./sounds/LOZ_text_slow.wav");
				}
			}
			ctx.fillStyle = "white";
			ctx.font = "12px Arial";
			ctx.fillText(gameObjects[i].line1Current, 
			gameObjects[i].line1X, gameObjects[i].line1Y);
			ctx.fillText(gameObjects[i].line2Current, 
			gameObjects[i].line2X, gameObjects[i].line2Y);
		}
		if(gameObjects[i].isFlame)
		{
			gameObjects[i].counter+=1;
			if(gameObjects[i].counter%5==0)
			{
				gameObjects[i].rupeeImage+=1;
			}
			if(gameObjects[i].rupeeImage > 1)
			{
				gameObjects[i].rupeeImage = 0;
			}
			if(gameObjects[i].rupeeImage == 0)
			{
				ctx.drawImage(chars2, 158, 11, 16, 16, 
						gameObjects[i].x, gameObjects[i].y, 16, 16);
			}
			else
			{
				ctx.drawImage(chars1, 52, 11, 16, 16, 
						gameObjects[i].x, gameObjects[i].y, 16, 16);
			}
		}
		if(gameObjects[i].isOldMan)
		{
			ctx.drawImage(chars1, 1, 11, 16, 16, 
						gameObjects[i].x, gameObjects[i].y, 16, 16);
		}
		if(gameObjects[i].isOldWoman)
		{
			ctx.drawImage(chars1, 35, 11, 16, 16, 
						gameObjects[i].x, gameObjects[i].y, 16, 16);
		}
		if(gameObjects[i].isRupee)
		{
			gameObjects[i].counter+=1;
			if(gameObjects[i].counter%5==0)
			{
				gameObjects[i].rupeeImage+=1;
			}
			if(gameObjects[i].rupeeImage > 1)
			{
				gameObjects[i].rupeeImage = 0;
			}
			if(gameObjects[i].rupeeImage == 0)
			{
				ctx.drawImage(link1, 244, 225, 8, 16, 
						gameObjects[i].x, gameObjects[i].y, 8, 16);
			}
			else
			{
				ctx.drawImage(link1, 274, 225, 8, 16, 
						gameObjects[i].x, gameObjects[i].y, 8, 16);
			}
		}
		if(gameObjects[i].isEnemy)
		{
			if(gameObjects[i].enemyType == 1)
			{
				gameObjects[i].counter++;
				if(gameObjects[i].x == gameObjects[i].nextX &&
				gameObjects[i].y == gameObjects[i].nextY)
				{
					gameObjects[i].nextX = -1;
					gameObjects[i].nextY = -1;
				}
				
				
				if(gameObjects[i].enemyPath.length == 0)
				{
					let currRow = Math.floor(gameObjects[i].y/16);
					let currCol = Math.floor(gameObjects[i].x/16);
					getNewCoordinates(currRow, currCol);
					gameObjects[i].enemyPath = copyArray(pathFound);
				}
			
				
				if(gameObjects[i].enemyPath[0] != null && 
				gameObjects[i].nextX == -1 && 
				gameObjects[i].nextY == -1)
				{
					gameObjects[i].nextX = gameObjects[i].enemyPath[0].col * 16;
					gameObjects[i].nextY = gameObjects[i].enemyPath[0].row * 16;
					gameObjects[i].enemyPath.splice(0,1);
				}
				if(gameObjects[i].counter >= 10)
				{
					gameObjects[i].frame++;
					gameObjects[i].counter = 0;
					if(gameObjects[i].frame > 1)
					{
						gameObjects[i].frame = 0;
					}
				}
				if(gameObjects[i].direction == "down")
				{
					if(gameObjects[i].frame == 0)
					{
						ctx.drawImage(enemies, 0, 0, 16, 16, 
						gameObjects[i].x, gameObjects[i].y, 16, 16);
					}
					if(gameObjects[i].frame == 1)
					{
						ctx.drawImage(enemies, 0, 30, 16, 16, 
						gameObjects[i].x, gameObjects[i].y, 16, 16);
					}
				}
				else if(gameObjects[i].direction == "up")
				{
					if(gameObjects[i].frame == 0)
					{
						ctx.drawImage(enemies, 60, 0, 16, 16, 
						gameObjects[i].x, gameObjects[i].y, 16, 16);
					}
					if(gameObjects[i].frame == 1)
					{
						ctx.drawImage(enemies, 60, 30, 16, 16, 
						gameObjects[i].x, gameObjects[i].y, 16, 16);
					}
				}
				else if(gameObjects[i].direction == "left")
				{
					if(gameObjects[i].frame == 0)
					{
						ctx.drawImage(enemies, 30, 0, 16, 16, 
						gameObjects[i].x, gameObjects[i].y, 16, 16);
					}
					if(gameObjects[i].frame == 1)
					{
						ctx.drawImage(enemies, 30, 30, 16, 16, 
						gameObjects[i].x, gameObjects[i].y, 16, 16);
					}
				}
				else
				{
					if(gameObjects[i].frame == 0)
					{
						ctx.drawImage(enemies, 90, 0, 16, 16, 
						gameObjects[i].x, gameObjects[i].y, 16, 16);
					}
					if(gameObjects[i].frame == 1)
					{
						ctx.drawImage(enemies, 90, 30, 16, 16, 
						gameObjects[i].x, gameObjects[i].y, 16, 16);
					}
				}
				
				if(gameObjects[i].needsBounce)
				{
					if(gameObjects[i].x != gameObjects[i].bounceX)
					{
						if(gameObjects[i].bounceX > gameObjects[i].x)
						{
							gameObjects[i].x += 4;
						}
						else if(gameObjects[i].bounceX < gameObjects[i].x)
						{
							gameObjects[i].x -= 4;
						}
					}
					else if(gameObjects[i].y != gameObjects[i].bounceY)
					{
						if(gameObjects[i].bounceY > gameObjects[i].y)
						{
							gameObjects[i].y += 4;
						}
						else if(gameObjects[i].bounceY < gameObjects[i].y)
						{
							gameObjects[i].y -= 4;
						}
					}
					else
					{
						gameObjects[i].needsBounce = false;
						if(gameObjects[i].health <= 0)
						{
							console.log("its health is: " + gameObjects[i].health);
							
							let rupeeChance = Math.floor(Math.random()*10);
							if(rupeeChance < 2)
							{
								gO = new GameObject()
								gO.x = gameObjects[i].x + 4;
								gO.y = gameObjects[i].y;
								gO.width = 8;
								gO.height = 16;
								gO.isRupee = true;
								gO.rupeeValue = 1;
								gameObjects.push(gO);
							}
							gameObjects.splice(i,1);
						}
					}
				}
				else
				{
					if(gameObjects[i].x != gameObjects[i].nextX)
					{
						if(gameObjects[i].nextX > gameObjects[i].x)
						{
							if(gameObjects[i].counter%3 == 0)
							{
								gameObjects[i].x += 1;
							}
							gameObjects[i].direction = "right";
						}
						else if(gameObjects[i].nextX < gameObjects[i].x)
						{
							if(gameObjects[i].counter%3 == 0)
							{
								gameObjects[i].x -= 1;
							}
							gameObjects[i].direction = "left";
						}
						
					}
					else if(gameObjects[i].y != gameObjects[i].nextY)
					{
						if(gameObjects[i].nextY > gameObjects[i].y)
						{
							if(gameObjects[i].counter%3 == 0)
							{
								gameObjects[i].y += 1;
							}
							gameObjects[i].direction = "down";
						}
						else if(gameObjects[i].nextY < gameObjects[i].y)
						{
							if(gameObjects[i].counter%3 == 0)
							{
								gameObjects[i].y -= 1;
							}
							gameObjects[i].direction = "up";
						}
					}
				}
			}
			if(gameObjects[i].enemyType == 2)
			{
				gameObjects[i].counter++;
				if(gameObjects[i].counter < 60)
				{
					////fire projectile
				}
				else if(gameObjects[i].counter == 60)
				{
					////fire projectile
				}
				else if(gameObjects[i].counter > 80)
				{
					//hide under water
				}
				else if(gameObjects[i].counter  >120)
				{
					//move coords
					gameObjects[i].counter = 0;
				}
			}
		}
	}
}


function getNewCoordinates(currentRow, currentCol)
{
	pathFound = [];
	let randRow = Math.floor(Math.random() * 11) + 4;
	let randCol = Math.floor(Math.random() * 16);
	
	//while(randRow > 14 || randRow < 0 ||
	//randCol > 15 || randRow < 0 ||
	while(gameMap[randRow][randCol] != 2)
	{
		randRow = Math.floor(Math.random() * 11) + 4;
	    randCol = Math.floor(Math.random() * 16);
	}
	///0-11 + 4 for rows
	//console.log("Game map at randRow and randCol: " + gameMap[randRow][randCol]);
	//console.log("Target node is: " + randRow + "   " + randCol);
	foundPath(currentRow, currentCol, randRow, randCol);
	while(pathFound.length == 0)
	{
		console.log("Old path didnt work, need new path..");
		randRow = Math.floor(Math.random() * 12) + 4;
		randCol = Math.floor(Math.random() * 16);
		foundPath(currentRow, currentCol, randRow, randCol);
	}
	
	//return new Point(randRow, randCol);
	
}

function foundPath(cR, cC, tR, tC)
{
	let visitedNodes = [];
	let currentNodes = [];
	if(cC >= 1 && gameMap[cR][cC - 1] == 2)
	{
		currentNodes.push(new Point(cR, cC - 1));
	}
	if(cC <= 14 && gameMap[cR][cC + 1] == 2)
	{
		currentNodes.push(new Point(cR, cC + 1));
	}
	if(cR >= 5 && gameMap[cR - 1][cC] == 2)
	{
		currentNodes.push(new Point(cR - 1, cC));
	}
	if(cR <= 14 && gameMap[cR + 1][cC] == 2)
	{
		currentNodes.push(new Point(cR + 1, cC));
	}
	//console.log("CurrentNodes: ");
	//console.log(currentNodes);
	visitedNodes.push(new Point(cR, cC));
	for(let i = 0; i < currentNodes.length; i++)
	{	
		visitedNodes.push(new Point(currentNodes[i].row,currentNodes[i].col ));
		if(currentNodes[i].row == tR &&
		currentNodes[i].col == tC)
		{
			pathFound = visitedNodes;
			break;
		}
		findRestOfRoute(currentNodes[i].row, currentNodes[i].col, 
						tR, tC, visitedNodes)
	}
	
}

function isInNodes(targetR, targetC, nodes)
{
	let isInList = false;
	for(let i = 0; i < nodes.length; i++)
	{
		if(nodes[i].row == targetR && nodes[i].col == targetC)
		{
			isInList = true;
			break;
		}
	}
	return isInList;
}

function copyArray(arr)
{
	let arr2 = [];
	for(let i = 0; i < arr.length; i++)
	{
		arr2.push(new Point(arr[i].row, arr[i].col));
	}
	return arr2;
}

function findRestOfRoute(cR, cC, tR, tC, vNodes2)
{
	let vNodes = copyArray(vNodes2);
	
	let currentNodes = [];
	
	if(cC >= 1 && gameMap[cR][cC - 1] == 2)
	{
		if(!isInNodes(cR, cC - 1, vNodes))
		{
			currentNodes.push(new Point(cR, cC - 1));
		}
	}
	if(cC <= 14 && gameMap[cR][cC + 1] == 2)
	{
		if(!isInNodes(cR, cC + 1, vNodes))
		{
			currentNodes.push(new Point(cR, cC + 1));
		}
	}
	if(cR >= 5 && gameMap[cR - 1][cC] == 2)
	{
		if(!isInNodes(cR - 1, cC, vNodes))
		{
			currentNodes.push(new Point(cR - 1, cC));
		}
	}
	if(cR <= 14 && gameMap[cR + 1][cC] == 2)
	{
		if(!isInNodes(cR +1, cC, vNodes))
		{
			currentNodes.push(new Point(cR + 1, cC));
		}
	}
	if(currentNodes.length == 0 || pathFound.length > 0 || 
		vNodes.length > 30)
	{
		return;
	}
	
	for(let i = 0; i < currentNodes.length; i++)
	{	
		vNodes.push(new Point(currentNodes[i].row, currentNodes[i].col));
		if(currentNodes[i].row == tR &&
		currentNodes[i].col == tC)
		{
			pathFound = copyArray(vNodes);
			//console.log("Path was found.");
			return;

		}
		findRestOfRoute(currentNodes[i].row, currentNodes[i].col, 
		tR, tC, vNodes);
	}
	
}


function gameObjectCollision(x, y, objects, isLink, isSword, isBomb, 
							isCandle, isArrow, direction)
{
	if(isLink)
	{
		for(let i = 0; i < objects.length; i++)
			{
				if (x <= objects[i].x + objects[i].width &&
				   x + 16 >= objects[i].x &&
				   y  <= objects[i].y + objects[i].height &&
				   y + 16 >= objects[i].y ) {
						if(objects[i].isPortal)
						{
							gameMap = maps[objects[i].newMap].map;
							gameObjects = maps[objects[i].newMap].gameobjects;
							currentMap = objects[i].newMap;
							addMapGameObjects(gameMap, gameObjects);
							if(objects[i].shiftsLeftRight)
							{
								linkX = objects[i].newLinkX;
							}
							else if(objects[i].shiftsUpDown)
							{
								linkY = objects[i].newLinkY;
							}
							else
							{
								linkX = objects[i].newLinkX;
								linkY = objects[i].newLinkY;
							}
							console.log("Switching portals");
							break;
							
						}
						if(objects[i].isPickUpItem)
						{
							playPickUpItemAnimation = true;
							///There are a number of pick up items. The first 8 are selctable within
							/// the inventory screen. The following 6 sit on top of the selectable inventory
							/// and are automatically equipped and used by link.
							//0 - boomerang
							//1 - bomb
							//2 - bow and arrow
							//3 - candle
							//4 - flute
							//5 - meat
							//6 - potion(red or blue)
							//7 - magic rod
							//8 - raft
							//9 - book of magic
							//10 - ring
							//11 - ladder
							//12 - key
							//13 - bracelet
							//14 - wood sword
							switch(gameObjects[i].pickUpItemNum)
							{
								
								case 0:
									
									break;
								case 1:
									gO = new GameObject();
									gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
									inventoryItems[gameObjects[i].pickUpItemNum] = gO;
									lastPickUpItem = gameObjects[i].pickUpItemNum;
									break;
								case 2:
									gO = new GameObject();
									gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
									inventoryItems[gameObjects[i].pickUpItemNum] = gO;
									lastPickUpItem = gameObjects[i].pickUpItemNum;
									break;
								case 3:
									gO = new GameObject();
									gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
									inventoryItems[gameObjects[i].pickUpItemNum] = gO;
									lastPickUpItem = gameObjects[i].pickUpItemNum;
									break;
								case 4:
									gO = new GameObject();
									gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
									inventoryItems[gameObjects[i].pickUpItemNum] = gO;
									lastPickUpItem = gameObjects[i].pickUpItemNum;
									break;
								case 5:
									gO = new GameObject();
									gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
									inventoryItems[gameObjects[i].pickUpItemNum] = gO;
									lastPickUpItem = gameObjects[i].pickUpItemNum;
									break;	
								case 6:
									gO = new GameObject();
									gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
									inventoryItems[gameObjects[i].pickUpItemNum] = gO;
									lastPickUpItem = gameObjects[i].pickUpItemNum;
									break;
								case 7:
									gO = new GameObject();
									gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
									inventoryItems[gameObjects[i].pickUpItemNum] = gO;
									lastPickUpItem = gameObjects[i].pickUpItemNum;
									break;
								case 8:
									gO = new GameObject();
									gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
									inventoryItems[gameObjects[i].pickUpItemNum] = gO;
									lastPickUpItem = gameObjects[i].pickUpItemNum;
									break;
								case 9:
									gO = new GameObject();
									gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
									inventoryItems[gameObjects[i].pickUpItemNum] = gO;
									lastPickUpItem = gameObjects[i].pickUpItemNum;
									break;
								case 10:
									gO = new GameObject();
									gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
									inventoryItems[gameObjects[i].pickUpItemNum] = gO;
									lastPickUpItem = gameObjects[i].pickUpItemNum;
									break;
								case 11:
									gO = new GameObject();
									gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
									inventoryItems[gameObjects[i].pickUpItemNum] = gO;
									lastPickUpItem = gameObjects[i].pickUpItemNum;
									break;
								case 12:
									gO = new GameObject();
									gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
									inventoryItems[gameObjects[i].pickUpItemNum] = gO;
									lastPickUpItem = gameObjects[i].pickUpItemNum;
									break;
								case 13:
									gO = new GameObject();
									gO.pickUpItemNum = gameObjects[i].pickUpItemNum;
									inventoryItems[gameObjects[i].pickUpItemNum] = gO;
									lastPickUpItem = gameObjects[i].pickUpItemNum;
									break;
								case 14:
									lastPickUpItem = 14;
									swordEquipped = 1;
									playSound("./sounds/item.mp3");
									
							}
							
							objects.splice(i,1);
							animationCounter = 0;
							break;
						}
						if(objects[i].isEnemy && !linkNeedsToBounce && !linkIsInvincible)
						{
							//
							linkNeedsToBounce = true;
							getBounceLocLink(objects[i].direction);
							playSound("./sounds/LOZ_link_hurt.wav");
							currentLinkHearts -= .5;
							linkIsInvincible = true;
							invincibleTime = 30;
							if(currentLinkHearts <= 0)
							{
								//link has died
							}
						}
						if(objects[i].isRupee)
						{
							rupeeAmount += 1;
							objects.splice(i,1);
							playSound("./sounds/LOZ_get_rupee.wav");
						}
					}
			}
	}
	////currently for sword attack
	else
	{
		let swordW = 11;
		let swordH = 3;
		if(lastButtonPressed == "up" ||
			lastButtonPressed == "down")
		{
			swordW = 3;
			swordH = 11;
		}
		
		for(let i = 0; i < objects.length; i++)
			{
				if(lastButtonPressed == "left")
				{
					if (x + 2 <= objects[i].x + objects[i].width &&
					x + 2 + swordW>= objects[i].x &&
					y + 6  <= objects[i].y + objects[i].height &&
					y + 6 + swordH >= objects[i].y ) 
					{
						//ctx.fillRect(x + 2, (y+6), swordW, swordH);
						if(objects[i].isEnemy)
								{
									//
									objects[i].health -= 1;
									objects[i].needsBounce = true;
									getBounceLoc(objects[i], false,
											direction);
									if(objects[i].health == 0)
									{
										playSound("./sounds/LOZ_enemy_die.wav");
									}
									else
									{
										playSound("./sounds/LOZ_enemy_hit.wav");
									}
								}
					}
				}
				else if(lastButtonPressed == "right")
				{
					if (x - 2<= objects[i].x + objects[i].width &&
					x - 2 + swordW>= objects[i].x &&
					y + 6  <= objects[i].y + objects[i].height &&
					y + 6 + swordH >= objects[i].y ) 
					{
						//ctx.fillRect(x - 2, (y+6), swordW, swordH);
						if(objects[i].isEnemy)
								{
									//
									objects[i].health -= 1;
									objects[i].needsBounce = true;
									getBounceLoc(objects[i], false,
											direction);
									if(objects[i].health == 0)
									{
										playSound("./sounds/LOZ_enemy_die.wav");
									}
									else
									{
										playSound("./sounds/LOZ_enemy_hit.wav");
									}
								}
					}
				}
				else if(lastButtonPressed == "up")
				{
					if (x - 2 <= objects[i].x + objects[i].width &&
					x - 2  + swordW>= objects[i].x &&
					y   <= objects[i].y + objects[i].height &&
					y  + swordH >= objects[i].y ) 
					{
						//ctx.fillRect(x - 2, y, swordW, swordH);
						if(objects[i].isEnemy)
								{
									//
									objects[i].health -= 1;
									objects[i].needsBounce = true;
									getBounceLoc(objects[i], false,
											direction);
									if(objects[i].health == 0)
									{
										playSound("./sounds/LOZ_enemy_die.wav");
									}
									else
									{
										playSound("./sounds/LOZ_enemy_hit.wav");
									}
								}
					}
				}
				else{
				
					if (x <= objects[i].x + objects[i].width &&
					x + swordW>= objects[i].x &&
					y  <= objects[i].y + objects[i].height &&
					y + swordH >= objects[i].y ) 
					{
						//ctx.fillRect(x, y, swordW, swordH);
						if(objects[i].isEnemy)
								{
									//
									objects[i].health -= 1;
									objects[i].needsBounce = true;
									getBounceLoc(objects[i], false,
											direction);
									if(objects[i].health == 0)
									{
										playSound("./sounds/LOZ_enemy_die.wav");
									}
									else
									{
										playSound("./sounds/LOZ_enemy_hit.wav");
									}
								}
					}
				}
		}
	}
}

function getBounceLoc(gObject, ignoresObjects, direction)
{
	let currRow = Math.floor(gObject.y/16);
	let currCol = Math.floor(gObject.x/16);
	if(direction == "up")
	{
		if(gameMap[currRow-1][currCol] == 2)
		{
			gObject.bounceY = gObject.y - 16 ;
			gObject.bounceX = gObject.x;
		}
		else
		{
			gObject.bounceY = gObject.y;
			gObject.bounceX = gObject.x;
		}
	}
	if(direction == "down")
	{
		if(gameMap[currRow+1][currCol] == 2)
		{
			gObject.bounceY = gObject.y + 16 ;
			gObject.bounceX = gObject.x;
		}
		else
		{
			gObject.bounceY = gObject.y;
			gObject.bounceX = gObject.x;
		}
	}
	if(direction == "left")
	{
		if(gameMap[currRow][currCol-1] == 2)
		{
			gObject.bounceX = gObject.x - 16 ;
			gObject.bounceY = gObject.y;
		}
		else
		{
			gObject.bounceY = gObject.y;
			gObject.bounceX = gObject.x;
		}
	}
	if(direction == "right")
	{
		if(gameMap[currRow][currCol+1] == 2)
		{
			gObject.bounceX = gObject.x + 16 ;
			gObject.bounceY = gObject.y;
		}
		else
		{
			gObject.bounceY = gObject.y;
			gObject.bounceX = gObject.x;
		}
	}
	console.log("New bx and by is: " + gObject.bounceX + "  " + gObject.bounceY);
}

function getBounceLocLink(direction)
{
	linkBounceX = linkX;
	linkBounceY = linkY;
	if(direction == "up")
	{
		while(!linkCollision(linkX, linkBounceY - 2, gameObjects) && 
				linkY - 16 !=  linkBounceY)
		{
			console.log("Inside while loop 1");
			console.log("LinBounceY == " + linkBounceY + "   and linkY == " + linkY);
			linkBounceY -= 2;
			
		}
	}
	if(direction == "down")
	{
		while(!linkCollision(linkX, linkBounceY + 2, gameObjects) && 
				linkY + 16 !=  linkBounceY)
		{
			console.log("Inside while loop 2");
			linkBounceY += 2;
		}
	}
	if(direction == "left")	
	{
		while(!linkCollision(linkBounceX - 2, linkY , gameObjects) && 
				linkX - 16 !=  linkBounceX)
		{
			console.log("Inside while loop 3");
			linkBounceX -= 2;
		}
	}
	if(direction == "right")
	{
		while(!linkCollision(linkBounceX + 2, linkY , gameObjects) && 
				linkX + 16 !=  linkBounceX)
		{
			console.log("Inside while loop 4");
			linkBounceX += 2;
		}
	}
}

function drawHUD()
{
	ctx.drawImage(hud, 258, 11, 256, 56, 
				0, 0, 256, 56);
	ctx.drawImage(hud, 2, 112, 16, 64, 
				176, 32, 64,  16);
	//draw Hearts
	let fullHearts = Math.floor(currentLinkHearts)
	let halfHearts = currentLinkHearts - fullHearts;
	for(let i = 0; i < linkHearts; i++)
	{
		let heartY = 40;
		let heartX = 176 + (i * 8);
		if(i > 7)
			{
				heartY = 40 - 8;
				heartX -= 64;
			}
			else
			{
				heartY = 40;
			}
		ctx.drawImage(hud, 627, 117, 8, 8, 
				heartX, heartY, 8, 8);
	}
	let halfHeartX = 0;
	let halfHeartY = 0;
	for(let i = 0; i < fullHearts; i++)
	{
		let heartY = 40;
		let heartX = 176 + (i * 8);
		if(i > 7)
			{
				heartY = 40 - 8;
				heartX -= 64;
			}
			else
			{
				heartY = 40;
			}
		ctx.drawImage(hud, 645, 117, 8, 8, 
				heartX, heartY, 8, 8);
		if(i == fullHearts - 1)
		{
			
			if(i > 6)
			{
				halfHeartY = 40 - 8;
				halfHeartX = 176 + ((i%7) * 8);
				
			}
			else
			{
				halfHeartY = 40;
				halfHeartX = 176 + (i * 8) + 8;
			}
		}	
	}
	
	if(halfHearts > 0 && fullHearts >= 1)
	{
		ctx.drawImage(hud, 636, 117, 8, 8, 
				halfHeartX, halfHeartY, 8, 8);
	}
	else if(halfHearts > 0 && fullHearts == 0)
	{
		ctx.drawImage(hud, 636, 117, 8, 8, 
				176, 40, 8, 8);
	}
	
	
	////This draws the rupee values
	///cover with black
	ctx.drawImage(hud, 354, 36, 24, 6, 
				96, 10, 24, 50);
	///124
	if(rupeeAmount < 100)
	{
		ctx.drawImage(hud, 519, 117, 8, 8, 
				96, 16, 8, 8);
		let firstNum = rupeeAmount %10;
		ctx.drawImage(hud, 528 + (8*firstNum) + (1*firstNum), 117, 8, 8, 
				96 + 16, 16, 8, 8);
		let secondNum = Math.floor(rupeeAmount/10);
		ctx.drawImage(hud, 528 + (8*secondNum) + (1*secondNum), 117, 8, 8, 
				96 + 8, 16, 8, 8);
	}
	else{
		let firstNum = rupeeAmount %10;
		ctx.drawImage(hud, 528 + (8*firstNum) + (1*firstNum), 117, 8, 8, 
				96 + 16, 16, 8, 8);
		let secondNum = Math.floor(rupeeAmount/10);
		let thirdNum = Math.floor(rupeeAmount/ 100) * 100;
		secondNum = ((rupeeAmount - thirdNum) - firstNum) / 10;
		ctx.drawImage(hud, 528 + (8*secondNum) + (1*secondNum), 117, 8, 8, 
				96 + 8, 16, 8, 8);
		thirdNum = Math.floor(rupeeAmount / 100);
		ctx.drawImage(hud, 528 + (8*thirdNum) + (1*thirdNum), 117, 8, 8, 
				96 , 16, 8, 8);
	}
	
	//draw bomb and key nums
	///key num
	ctx.drawImage(hud, 519, 117, 8, 8, 
				96, 32, 8, 8);
	ctx.drawImage(hud, 528 + (8*keyNum) + (1*keyNum), 117, 8, 8, 
				96 + 8, 32, 8, 8);
	///bomb num
	ctx.drawImage(hud, 519, 117, 8, 8, 
				96, 41, 8, 8);
	ctx.drawImage(hud, 528 + (8*bombNum) + (1*bombNum), 117, 8, 8, 
				96 + 8, 41, 8, 8);
	
	///Sword and B button items
	ctx.fillStyle = "black";
	ctx.fillRect(128, 24, 8, 16);
	ctx.fillRect(152, 24, 8, 16);
	if(swordEquipped == 1)
	{
		ctx.drawImage(hud, 555, 137, 8, 16, 
				152 , 24, 8, 16);
	}
	
	///Fill map location in with gray
	ctx.fillStyle = "gray";
	ctx.fillRect(16, 8, 64, 48);
}

function drawGameStart()
{
	ctx.fillStyle = "rgb(255,255,255)";
	ctx.font = "20px Arial";
	ctx.fillText("Push enter to start", 40, 120);
}

function linkCollision(x, y, objects)
{
	for(let i = 0; i < objects.length; i++)
	{
		if (x <= objects[i].x + objects[i].width &&
		   x + 16 >= objects[i].x &&
		   y + 10 <= objects[i].y + objects[i].height &&
		   y + 16 >= objects[i].y ) {
				return true;
			}
	}
	return false;
}

function addMapGameObjects(levelMap, objectArray)
{
	for(let i = 4; i < levelMap.length; i++)
	{
		for(let j = 0; j < levelMap[0].length; j++)
		{
			if(i == 4)
			{
				if(levelMap[i][j] == 2 
				|| levelMap[i][j] == 28 
				|| levelMap[i][j] == 18
				|| levelMap[i][j] == 6
				|| levelMap[i][j] == 12
				|| levelMap[i][j] == 14
				|| levelMap[i][j] == 24
				|| levelMap[i][j] == 30
				|| levelMap[i][j] == 34
				|| levelMap[i][j] == 58
				|| levelMap[i][j] == 64
				|| levelMap[i][j] == 70
				|| levelMap[i][j] == 75
				|| levelMap[i][j] == 76
				|| levelMap[i][j] == 77
				|| levelMap[i][j] == 93
				|| levelMap[i][j] == 94
				|| levelMap[i][j] == 95
				|| levelMap[i][j] == 111
				|| levelMap[i][j] == 112
				|| levelMap[i][j] == 113
				|| levelMap[i][j] == 81
				|| levelMap[i][j] == 82
				|| levelMap[i][j] == 83
				|| levelMap[i][j] == 99
				|| levelMap[i][j] == 100
				|| levelMap[i][j] == 101
				|| levelMap[i][j] == 117
				|| levelMap[i][j] == 118
				|| levelMap[i][j] == 119
				|| levelMap[i][j] == 87
				|| levelMap[i][j] == 88
				|| levelMap[i][j] == 89
				|| levelMap[i][j] == 105
				|| levelMap[i][j] == 106
				|| levelMap[i][j] == 107
				|| levelMap[i][j] == 123
				|| levelMap[i][j] == 124
				|| levelMap[i][j] == 125
				|| levelMap[i][j] == 126
				|| levelMap[i][j] == 127
				|| levelMap[i][j] == 128
				|| levelMap[i][j] == 129
				|| levelMap[i][j] == 131
				|| levelMap[i][j] == 132
				|| levelMap[i][j] == 133
				|| levelMap[i][j] == 134
				|| levelMap[i][j] == 135
				|| levelMap[i][j] == 137
				|| levelMap[i][j] == 138
				|| levelMap[i][j] == 139
				|| levelMap[i][j] == 140
				|| levelMap[i][j] == 141
				|| levelMap[i][j] == 143)
				{
					gO = new GameObject()
					gO.x = j * 16;
					gO.y = 3 * 16;
					gO.width = 16;
					gO.height = 16;
					gO.newMap = currentMap - 16;
					gO.newLinkX = (j * 16) +1; 
					gO.newLinkY = 223;
					gO.isPortal = true;
					gO.shiftsUpDown = true;
					gameObjects.push(gO);
				}
			}
			else if(i == 14)
			{
				if(levelMap[i][j] == 2 
				|| levelMap[i][j] == 28 
				|| levelMap[i][j] == 18
				|| levelMap[i][j] == 6
				|| levelMap[i][j] == 12
				|| levelMap[i][j] == 14
				|| levelMap[i][j] == 24
				|| levelMap[i][j] == 30
				|| levelMap[i][j] == 34
				|| levelMap[i][j] == 58
				|| levelMap[i][j] == 64
				|| levelMap[i][j] == 70
				|| levelMap[i][j] == 75
				|| levelMap[i][j] == 76
				|| levelMap[i][j] == 77
				|| levelMap[i][j] == 93
				|| levelMap[i][j] == 94
				|| levelMap[i][j] == 95
				|| levelMap[i][j] == 111
				|| levelMap[i][j] == 112
				|| levelMap[i][j] == 113
				|| levelMap[i][j] == 81
				|| levelMap[i][j] == 82
				|| levelMap[i][j] == 83
				|| levelMap[i][j] == 99
				|| levelMap[i][j] == 100
				|| levelMap[i][j] == 101
				|| levelMap[i][j] == 117
				|| levelMap[i][j] == 118
				|| levelMap[i][j] == 119
				|| levelMap[i][j] == 87
				|| levelMap[i][j] == 88
				|| levelMap[i][j] == 89
				|| levelMap[i][j] == 105
				|| levelMap[i][j] == 106
				|| levelMap[i][j] == 107
				|| levelMap[i][j] == 123
				|| levelMap[i][j] == 124
				|| levelMap[i][j] == 125
				|| levelMap[i][j] == 126
				|| levelMap[i][j] == 127
				|| levelMap[i][j] == 128
				|| levelMap[i][j] == 129
				|| levelMap[i][j] == 131
				|| levelMap[i][j] == 132
				|| levelMap[i][j] == 133
				|| levelMap[i][j] == 134
				|| levelMap[i][j] == 135
				|| levelMap[i][j] == 137
				|| levelMap[i][j] == 138
				|| levelMap[i][j] == 139
				|| levelMap[i][j] == 140
				|| levelMap[i][j] == 141
				|| levelMap[i][j] == 143)
				{
					gO = new GameObject()
					gO.x = j * 16;
					gO.y = (i + 1) * 16;
					gO.width = 16;
					gO.height = 16;
					gO.newMap = currentMap + 16;
					gO.newLinkX = (j * 16) + 1;
					gO.newLinkY = 81;
					gO.isPortal = true;
					gO.shiftsUpDown = true;
					gameObjects.push(gO);
				}
			}
			else if(j == 0)
			{
				if(levelMap[i][j] == 2 
				|| levelMap[i][j] == 28 
				|| levelMap[i][j] == 18
				|| levelMap[i][j] == 6
				|| levelMap[i][j] == 12
				|| levelMap[i][j] == 14
				|| levelMap[i][j] == 24
				|| levelMap[i][j] == 30
				|| levelMap[i][j] == 34
				|| levelMap[i][j] == 58
				|| levelMap[i][j] == 64
				|| levelMap[i][j] == 70
				|| levelMap[i][j] == 75
				|| levelMap[i][j] == 76
				|| levelMap[i][j] == 77
				|| levelMap[i][j] == 93
				|| levelMap[i][j] == 94
				|| levelMap[i][j] == 95
				|| levelMap[i][j] == 111
				|| levelMap[i][j] == 112
				|| levelMap[i][j] == 113
				|| levelMap[i][j] == 81
				|| levelMap[i][j] == 82
				|| levelMap[i][j] == 83
				|| levelMap[i][j] == 99
				|| levelMap[i][j] == 100
				|| levelMap[i][j] == 101
				|| levelMap[i][j] == 117
				|| levelMap[i][j] == 118
				|| levelMap[i][j] == 119
				|| levelMap[i][j] == 87
				|| levelMap[i][j] == 88
				|| levelMap[i][j] == 89
				|| levelMap[i][j] == 105
				|| levelMap[i][j] == 106
				|| levelMap[i][j] == 107
				|| levelMap[i][j] == 123
				|| levelMap[i][j] == 124
				|| levelMap[i][j] == 125
				|| levelMap[i][j] == 126
				|| levelMap[i][j] == 127
				|| levelMap[i][j] == 128
				|| levelMap[i][j] == 129
				|| levelMap[i][j] == 131
				|| levelMap[i][j] == 132
				|| levelMap[i][j] == 133
				|| levelMap[i][j] == 134
				|| levelMap[i][j] == 135
				|| levelMap[i][j] == 137
				|| levelMap[i][j] == 138
				|| levelMap[i][j] == 139
				|| levelMap[i][j] == 140
				|| levelMap[i][j] == 141
				|| levelMap[i][j] == 143)
				{
					gO = new GameObject()
					gO.x = -16;
					gO.y = i * 16;
					gO.width = 16;
					gO.height = 16;
					gO.newMap = currentMap - 1;
					gO.newLinkX = 223;
					gO.newLinkY = (i * 16) - 1;
					gO.isPortal = true;
					gO.shiftsLeftRight = true;
					gameObjects.push(gO);
				}
			}
			else if(j == 15)
			{
				if(levelMap[i][j] == 2 
				|| levelMap[i][j] == 28 
				|| levelMap[i][j] == 18
				|| levelMap[i][j] == 6
				|| levelMap[i][j] == 12
				|| levelMap[i][j] == 14
				|| levelMap[i][j] == 24
				|| levelMap[i][j] == 30
				|| levelMap[i][j] == 34
				|| levelMap[i][j] == 58
				|| levelMap[i][j] == 64
				|| levelMap[i][j] == 70
				|| levelMap[i][j] == 75
				|| levelMap[i][j] == 76
				|| levelMap[i][j] == 77
				|| levelMap[i][j] == 93
				|| levelMap[i][j] == 94
				|| levelMap[i][j] == 95
				|| levelMap[i][j] == 111
				|| levelMap[i][j] == 112
				|| levelMap[i][j] == 113
				|| levelMap[i][j] == 81
				|| levelMap[i][j] == 82
				|| levelMap[i][j] == 83
				|| levelMap[i][j] == 99
				|| levelMap[i][j] == 100
				|| levelMap[i][j] == 101
				|| levelMap[i][j] == 117
				|| levelMap[i][j] == 118
				|| levelMap[i][j] == 119
				|| levelMap[i][j] == 87
				|| levelMap[i][j] == 88
				|| levelMap[i][j] == 89
				|| levelMap[i][j] == 105
				|| levelMap[i][j] == 106
				|| levelMap[i][j] == 107
				|| levelMap[i][j] == 123
				|| levelMap[i][j] == 124
				|| levelMap[i][j] == 125
				|| levelMap[i][j] == 126
				|| levelMap[i][j] == 127
				|| levelMap[i][j] == 128
				|| levelMap[i][j] == 129
				|| levelMap[i][j] == 131
				|| levelMap[i][j] == 132
				|| levelMap[i][j] == 133
				|| levelMap[i][j] == 134
				|| levelMap[i][j] == 135
				|| levelMap[i][j] == 137
				|| levelMap[i][j] == 138
				|| levelMap[i][j] == 139
				|| levelMap[i][j] == 140
				|| levelMap[i][j] == 141
				|| levelMap[i][j] == 143)
				{
					gO = new GameObject()
					gO.x = 256;
					gO.y = i * 16;
					gO.width = 16;
					gO.height = 16;
					gO.newMap = currentMap + 1;
					gO.newLinkX = 1;
					gO.newLinkY = (i * 16) - 2;
					gO.isPortal = true;
					gO.shiftsLeftRight = true;
					gameObjects.push(gO);
				}
			}
			if(levelMap[i][j] != 2 && false)
			{
				gO = new GameObject()
				gO.x = j * 16;
				gO.y = i * 16;
				gO.width = 16;
				gO.height = 16;
				objectArray.push(gO);
			}
		}
	}
}



function draw () {
   setTimeout(function() {
   requestAnimationFrame(draw);
   ctx.fillStyle = "rgb(20,20,20)";
   ctx.fillRect(0,0,800,600);
   ///all code goes here
    if(!hasGameStarted)
	{
		drawGameStart();
	}
	else
	{
		invincibleTime--;
		if(invincibleTime <= 0)
		{
			linkIsInvincible = false;
		}
		drawMap(gameMap);
		drawLink();
		gameObjectCollision(linkX, linkY, gameObjects, true, false, false, false, false);
		drawGameObjects();
		drawHUD();
	}
   },1000/fps);
}
draw();

</script>
</body>
</html>

